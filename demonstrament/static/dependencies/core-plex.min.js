function e(e){if(e.length<3)return"{"+e+"}";for(var t=-1,n=2;n<e.length;n++)if("."===e[n]&&"."===e[n-1]&&(n<2||"\\"!==e[n-2])){if(t>-1)return"{"+e+"}";t=n-1}if(t>-1){var s=e.substr(0,t),r=e.substr(t+2);if(s.length>0&&r.length>0)return"["+e.substr(0,t)+"-"+e.substr(t+2)+"]"}return"{"+e+"}"}function t(n){if("string"!=typeof n)throw new TypeError("A pattern must be a string, but "+typeof n+" given");for(var s,r=!1,a=0,i=0,o=-1,c=[""],u=[],l=0;l<n.length;l++){var p=n[l];if("\\"!==p){if("{"===p)if(r)a++;else if(l>o&&!a){s=n.substring(o+1,l);for(var f=0;f<c.length;f++)c[f]+=s;u=[],o=l,r=!0,a++}else a--;else if("}"===p)if(r)i++;else if(1===i){if(s=n.substring(o+1,l),u.length>0){var g=[];u.push(t(s));for(f=0;f<c.length;f++)for(var h=0;h<u.length;h++)for(var d=0;d<u[h].length;d++)g.push(c[f]+u[h][d]);c=g}else{s=e(s);for(f=0;f<c.length;f++)c[f]+=s}o=l,i--}else i--;else r||","!==p||i-a!==1||(s=n.substring(o+1,l),u.push(t(s)),o=l);!r||i!==a&&l!==n.length-1||(r=!1,l=o-1)}else l++}if(-1===o)return[n];var b="{"===n[o]?o:o+1;if(b<n.length){s=n.substr(b);for(f=0;f<c.length;f++)c[f]+=s}return c}function n(e,t){var n,s=!1!==t["!"],r=!1!==t["()"],a=!1;if(s){for(n=0;n<e.length&&"!"===e[n];n++){if(r&&"("===e[n+1]){n--;break}a=!a}n>0&&(e=e.substr(n))}return{pattern:e,isNegated:a}}function s(e){return"-"===e||"^"===e||"$"===e||"+"===e||"."===e||"("===e||")"===e||"|"===e||"["===e||"]"===e||"{"===e||"}"===e||"*"===e||"?"===e||"\\"===e?"\\"+e:e}function r(e,t,n){var r=void 0===t.separator||t.separator,a="",i="",o=".";!0===r?(a="/",i="[/\\\\]",o="[^/\\\\]"):o=r?(i=function(e){for(var t="",n=0;n<e.length;n++)t+=s(e[n]);return t}(a=r)).length>1?"((?!"+(i="(?:"+i+")")+").)":"[^"+i+"]":".";var c=r?i+"+?":"",u=r?i+"*?":"",l=r?e.split(a):[e];return{source:e,segments:l,options:t,separator:r,separatorSplitter:a,separatorMatcher:i,optionalSeparator:u,requiredSeparator:c,wildcard:o,support:{qMark:!1!==t["?"],star:!1!==t["*"],globstar:r&&!1!==t["**"],brackets:!1!==t["[]"],extglobs:!1!==t["()"],excludeDot:n&&!1!==t.excludeDot}}}function a(e,t,n,s){return{source:e,isFirst:n,isLast:s,end:e.length-1}}var i="(?!\\.)";function o(e,t,n){return e.addToUnmatch&&(e.result.unmatch+=t),e.addToMatch&&(n&&!e.dotHandled&&(t=i+t),e.dotHandled=!0,e.result.match+=t),e.result}function c(e,t,n){var r=e.support,a=function(e,t,n){return{pattern:e,segment:t,result:n,openingBracket:t.end+1,closingBracket:-1,openingParens:0,closingParens:0,parensHandledUntil:-1,extglobModifiers:[],scanningForParens:!1,escapeChar:!1,addToMatch:!0,addToUnmatch:e.support.extglobs,dotHandled:!1,i:-1,char:"",nextChar:""}}(e,t,n),c=t.isLast?e.optionalSeparator:e.requiredSeparator;if(r.excludeDot||(a.dotHandled=!0),-1===t.end)return t.isLast&&!t.isFirst?n:o(a,c);if(r.globstar&&"**"===t.source)return o(a,"(?:"+((a.dotHandled?"":i)+e.wildcard+"*?"+c)+")*?");for(;++a.i<=t.end;){if(a.char=a.segment.source[a.i],a.nextChar=a.i<t.end?t.source[a.i+1]:"","\\"===a.char){if(a.i<a.segment.end){a.escapeChar=!0;continue}a.char=""}e=a.pattern,t=a.segment;var u=a.char,l=a.i;if(e.support.brackets&&!a.scanningForParens){if(l>a.openingBracket&&l<=a.closingBracket){a.escapeChar?o(a,s(u)):l===a.closingBracket?(o(a,"]"),a.openingBracket=t.source.length):"-"===u&&l===a.closingBracket-1?o(a,"\\-"):"!"===u&&l===a.openingBracket+1?o(a,"^"):o(a,"]"===u?"\\]":u),a.escapeChar=!1;continue}if(l>a.openingBracket){"]"===u&&!a.escapeChar&&l>a.openingBracket+1&&l>a.closingBracket?(a.closingBracket=l,a.i=a.openingBracket,e.separator?o(a,"(?!"+e.separatorMatcher+")[",!0):o(a,"[",!0)):l===t.end&&(o(a,"\\["),a.i=a.openingBracket,a.openingBracket=t.source.length,a.closingBracket=t.source.length),a.escapeChar=!1;continue}if("["===u&&!a.escapeChar&&l>a.closingBracket&&l<t.end){a.openingBracket=l,a.escapeChar=!1;continue}}if(a.pattern.support.extglobs){var p=a.extglobModifiers,f=(u=a.char,a.nextChar);l=a.i;if("("!==f||a.escapeChar||"@"!==u&&"?"!==u&&"*"!==u&&"+"!==u&&"!"!==u){if(")"!==u||a.escapeChar){if("|"===u&&a.closingParens&&!a.scanningForParens&&!a.escapeChar){o(a,"|");continue}}else if(a.scanningForParens)a.closingParens++;else if(p.length){var g=p.pop();if("!"===g&&-1!==p.indexOf("!"))throw new Error("Nested negated extglobs aren't supported");o(a,")"+(g="!"===g||"@"===g?"":g)),a.addToMatch=!0,a.addToUnmatch=!0,a.closingParens--;continue}}else if(a.scanningForParens)a.openingParens++;else if(l>a.parensHandledUntil&&!a.closingParens)a.parensHandledUntil=l,a.scanningForParens=!0,a.openingParens++;else{if(a.closingParens>=a.openingParens){"!"===u&&(a.addToMatch=!0,a.addToUnmatch=!1,o(a,a.pattern.wildcard+"*?",!0),a.addToMatch=!1,a.addToUnmatch=!0,a.result.useUnmatch=!0),p.push(u),o(a,"(?:",!0),a.openingParens--,a.i++;continue}a.openingParens--}if(a.scanningForParens){a.closingParens!==a.openingParens&&l!==a.segment.end||(a.scanningForParens=!1,a.i=a.parensHandledUntil-1),a.escapeChar=!1;continue}}r=(e=a.pattern).support;!a.escapeChar&&r.star&&"*"===a.char?a.i!==a.segment.end&&"*"===a.nextChar||o(a,e.wildcard+"*?",!0):!a.escapeChar&&r.qMark&&"?"===a.char?o(a,e.wildcard,!0):o(a,s(a.char)),a.escapeChar=!1}return o(a,c)}function u(e,t,n){for(var s=r(e,t,n),i={match:"",unmatch:"",useUnmatch:!1},o=s.segments,u=0;u<o.length;u++){c(s,a(o[u],0,0===u,u===o.length-1),i)}return i.useUnmatch?"(?!^"+i.unmatch+"$)"+i.match:i.match}function l(e,t){if("string"!=typeof t)throw new TypeError("Sample must be a string, but "+typeof t+" given");return e.test(t)}function p(e,s){if("string"!=typeof e&&!Array.isArray(e))throw new TypeError("The first argument must be a single pattern string or an array of patterns, but "+typeof e+" given");if("string"!=typeof s&&"boolean"!=typeof s||(s={separator:s}),2===arguments.length&&void 0!==s&&("object"!=typeof s||null===s||Array.isArray(s)))throw new TypeError("The second argument must be an options object or a string/boolean separator, but "+typeof s+" given");if("\\"===(s=s||{}).separator)throw new Error("\\ is not a valid separator");var r=function(e,s){e=Array.isArray(e)?e:[e],!1!==s["{}"]&&(e=function(e,t){for(var n=[],s=0;s<e.length;s++)for(var r=t(e[s]),a=0;a<r.length;a++)n.push(r[a]);return n}(e,t));for(var r=[],a=[],i="",o=0;o<e.length;o++){var c=n(e[o],s),l=u(c.pattern,s,!c.isNegated);c.isNegated?a.push(l):r.push(l)}return a.length&&(i="(?!(?:"+a.join("|")+")$)"),r.length>1?i+="(?:"+r.join("|")+")":1===r.length?i+=r[0]:i.length&&(i+=u("**",s,!0)),"^"+i+"$"}(e,s),a=new RegExp(r,s.flags),i=l.bind(null,a);return i.options=s,i.pattern=e,i.regexp=a,i}function f(e,t){const n=/([a-zA-Z_][a-zA-Z0-9_]*)|(\d+)|\["([^"]*)"\]|"([^"]*)"|\./g,s=[];let r;for(;null!==(r=n.exec(e));)r[1]?s.push(r[1]):r[2]?t?s.push(parseInt(r[2],10)):s.push(r[2]):r[3]?s.push(r[3]):r[4]&&s.push(r[4]);return s}var g=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();const h={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},d=(Object.keys(h),Object.values(h),{object:Object,array:Array,eventTarget:EventTarget,map:Map}),b=Object.keys(d),v=(Object.values(d),Object.assign({},h,d));Object.keys(v),Object.values(v),h.String,h.Number,h.Boolean;const y={Object:function(...e){if(1===e.length){const[t]=e;return t}{const[t,n]=e;return t[n]}},Map:function(...e){if(1===e.length){let[t]=e;return t}{let[t,n]=e;return t.get(n)}}},j={Object:function(...e){if(["string","number"].includes(g(e[1]))){const[t,n,s]=e;return t[n]=s,t[n]}{const[t,n]=e;for(const e of Object.keys(t))delete t[e];for(const[e,s]of Object.entries(n))t[e]=s;return t}},Map:function(...e){if(2===e.length){let[t,n]=e;t.clear();for(const[e,n]of Object.entries(source))t.set(e,n);return t}{let[t,n,s]=e;return t.set(n,s),t.get(n)}}},m={Object:function(...e){const[t,n]=e;if(["string","number"].includes(g(n)))return delete t[n];for(const e of Object.keys(t))delete t[e]},Map:function(...e){if(2===e.length){let[t,n]=e;return t.delete(n)}{let[t]=e;return t.clear()}}},O={Object:e=>!(e instanceof Map)&&["array","object"].includes(typeof e),Map:e=>e instanceof Map};class M extends EventTarget{constructor(e,t){super(),Object.defineProperties(this,{cess:{value:function(...n){let s=0;e:for(const r of e){if(s>=e.length)break e;if((0,t[s])(n[0]))return r(...n);s++}}}})}}const E={pathParseInteger:!1,getters:[y.Object,y.Map],typeValidators:[O.Object,O.Map],ancestors:[],depth:0,maxDepth:10,enumerable:!0,nonenumerable:!1,recurse:!0};function w(e,t,n={}){g(e);const s=[],r=Object.assign({},E,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:a,maxDepth:i,enumerable:o,nonenumerable:c,recurse:u}=r;if(r.depth>=i)return;a.includes(e)||a.unshift(e),r.depth++;const l=new M(r.getters,r.typeValidators),p=l.cess(e);if(!p)return s;const f="map"===g(p)?p.keys():Object.keys(p);for(let n of f){!isNaN(n)&&r.pathParseInteger&&(n=parseInt(n,10));const i=l.cess(e,n),p="map"!==g(e)?Object.getOwnPropertyDescriptor(e,n):{enumerable:!0,value:i};if(o&&p.enumerable||c&&!p.enumerable){const e=p.get?.call?p.get.call():p.value,i=g(e);if(u&&b.includes(i)&&!a.includes(e)){a.unshift(e);const i=w(e,t,r);i.length?"entries"===t?s.push([n,i]):"values"===t?s.push(i):"keys"===t&&s.push(n,i):"entries"===t?s.push([n,e]):"values"===t?s.push(e):"keys"===t&&s.push(n)}else"entries"===t?s.push([n,e]):"values"===t?s.push(e):"keys"===t&&s.push(n)}}return s}const k={depth:0,getters:[y.Object,y.Map],typeValidators:[O.Object,O.Map],maxDepth:10,values:!1,returnValue:"receiver"};function P(e,t={}){const n=[],s=Object.assign({},k,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:r,values:a}=s;if(s.depth++,s.depth>s.maxDepth)return n;const i=new M(s.getters,s.typeValidators).cess(e);r.includes(e)||r.unshift(e);const o=w(e,"entries",Object.assign({},s,{recurse:!1}));for(const[e,t]of o)if(a?a&&n.push([e,t]):n.push(e),"object"==typeof t&&null!==t&&!Object.is(t,i)&&!r.includes(t)){const r=P(t,s);if(a){if(a)for(const[t,s]of r){const r=[e,t].join(".");n.push([r,s])}}else for(const t of r){const s=[e,t].join(".");n.push(s)}}return n}const x={pathMatch:!1,pathMatchMaxResults:1e3,pathParseInteger:!1,getters:[y.Object,y.Map],typeValidators:[O.Object,O.Map]};function D(){const[e,t,n]=[...arguments],s=Object.assign({},x,n),r=new M(s.getters,s.typeValidators);if(void 0===t)return r.cess(e,s);const a=f(t,s.pathParseInteger);if(s.pathMatch){const n=[],r=P(e,Object.assign({},s,{values:!0})),a=p(t,{separator:"."});for(const[e,t]of r){!0===a(e)&&n.push([e,t])}return n}{let t=e;e:for(const e of a)try{if(t=r.cess(t,e),void 0===t)break e}catch(e){break e}return t}}const C={strict:!0};function V(e,t){const n=Object.assign({},C,t);let s;const r=g(e);if("array"===r)s=!0;else if("object"===r&&e.length>=0&&Number.isInteger(e.length))if(!1===n.strict)s=!0;else{e:for(const t of w(e,"keys",{nonenumerable:!0,recurse:!1}).reverse()){if(Number(t)===e.length-1){s=!0;break e}}void 0===s&&(s=!1)}else s=!1;return s}const B={strict:!0};function T(e,t){const n=Object.assign({},B,t);let s;const r=g(e);if("map"===r)s=!0;else if("object"===r&&e.size>=0&&Number.isInteger(e.size))if(!1===n.strict)s=!0;else{e:for(const t of w(e,"entries",{nonenumerable:!0,recurse:!1})){if(!V(t,n)&&2!==t.length){s=!1;break e}s=!0}void 0===s&&(s=!1)}else s=!1;return s}function A(e){const t=g(e);if("string"===t){const t=e.toLowerCase();if("object"===t)return Object();if("array"===t)return Array();if("map"===t)return new Map}else{if("object"===t)return Object();if(V(e,{strict:!0}))return Array();if(T(e,{strict:!0}))return new Map}}const _={pathMatch:!1,pathMatchMaxResults:1e3,pathParseInteger:!1,getters:[y.Object,y.Map],setters:[j.Object,j.Map],typeValidators:[O.Object,O.Map]};function I(){const e=[...arguments],[t,n,s,r]=e,a=Object.assign({},_,r),i=new M(a.getters,a.typeValidators),o=new M(a.setters,a.typeValidators);if(a.pathMatch){const e=[],r=P(t,Object.assign({},a,{values:!0})),i=p(n,{separator:"."});for(const[n,o]of r){!0===i(n,{separator:"."})&&(I(t,n,s,{pathMatch:!1,pathParseInteger:a.pathParseInteger}),e.push([n,s]))}return e}if("string"===g(e[1])){const{enumerable:e,nonenumerable:r}=a;i.cess(t);const c=f(n,a.pathParseInteger),u=c.pop();let l=t;e:for(const e of c)if(l=i.cess(l,e,a)||o.cess(l,e,isNaN(e)?{}:[]),void 0===l)break e;return o.cess(l,u,s,a),t}{const[t,n]=e;return t}}const L={pathMatch:!1,pathMatchMax:100,pathParseInteger:!1,deleters:[m.Object,m.Map],typeValidators:[O.Object,O.Map]};function N(e,t,n){const s=Object.assign({},L,n),r=new M(s.deleters,s.typeValidators);if(s.pathMatch){const n=[],r=P(e,Object.assign({},s,{values:!0})),a=p(t,{separator:"."});for(const[t,i]of r){!0===a(t,{separator:"."})&&(N(e,t,{pathMatch:!1,pathParseInteger:s.pathParseInteger}),n.push([t,void 0]))}return n}{const n=f(t,s.pathParseInteger),a=n.pop(),i=D(e,n.join("."),s)||e;r.cess(i,a)}}const U=["string","function"];function z(e,t,n={}){const s=Object.assign({},n),r=g(t),a=g(e);if(!U.includes(r)||!b.includes(a))return e;let i=A(e);for(const[n,a]of w(e,"entries",Object.assign({},s,{recurse:!1}))){const e=b.includes(g(a))?z(a,t,s):a;r===U[0]?i[n]=I({},t,e,s):r===U[1]&&(i[n]=t(e))}return i}const F={ancestors:[],getters:[y.Object,y.Map],typeValidators:[O.Object,O.Map],depth:0,maxDepth:10};function S(e,t,n={}){const s=Object.assign({},F,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:r,values:a}=s;if(s.depth>s.maxDepth)return;s.depth++;const i=new M(s.getters,s.typeValidators).cess(e);r.includes(i)||r.unshift(i);const o=g(t);let c=A(e);for(const[n,r]of w(e,"entries",Object.assign({},s,{recurse:!1})))"string"===o?c[n]=D(r,t):"function"===o&&(c[n]=t(r)),c[n]&&"object"==typeof c[n]&&(c[n]=S(c[n],t));return c}const H={setters:[j.Object,j.Map]};function K(e,t){const n=Object.assign({},H,t),s="object"===g(e)?w(e,"entries",n):e;if(!s)return;const r=isNaN(s[0][0])?{}:[];for(const[e,t]of s)I(r,e,t,n);return r}const q={getters:[y.Object,y.Map],setters:[j.Object,j.Map],typeValidators:[O.Object,O.Map]};function $(e,t,...n){if(!e)return e;const s=Object.assign({},q),r=new M(s.getters,s.typeValidators),a=new M(s.setters,s.typeValidators),i=g(e);e:for(const s of n){if(!b.includes(g(s)))continue e;const n=w(s,"entries",{recurse:!1});for(const[s,o]of n){const n=r.cess(e,s),c=g(n),u=g(o);"array"===i&&"assignConcat"===t?a.cess(e,e.length,o):b.includes(u)&&b.includes(c)?$(n,t,o):a.cess(e,s,o)}}}var R=(e,...t)=>$(e,"assign",...t),Z=(e,...t)=>$(e,"assignConcat",...t);const J={typeCoercion:!1};function G(e,t,n,s){const r=Object.assign({},n);let a=r.value;const i=Object.assign({},J,s),o=g(r.value),c=e[t],u=g(c);if(b.includes(o))if(b.includes(u))r.value=Q(c,a,i);else{const e=A(V(Object.defineProperties({},a))?"array":"object");r.value=Q(e,a,i)}else i.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(r,"type")&&!["undefined"].includes(o)&&(r.value=new h[r.type](a));return Object.defineProperty(e,t,r),n.sealed&&Object.seal(e[t]),n.frozen&&Object.freeze(e[t]),e}function Q(e,t,n){for(const[s,r]of Object.entries(t))G(e,s,r,n);return e}const W={getters:[y.Object,y.Map],typeValidators:[O.Object,O.Map],ancestors:[],depth:0,maxDepth:10};function X(e,t={}){const n=Object.assign({},W,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:s,values:r}=n;if(n.depth>n.maxDepth)return;n.depth++;const a=new M(n.getters,n.typeValidators).cess(e);s.includes(a)||s.unshift(a);const i=w(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,t]of i)s.includes(t)||b.includes(g(t))&&X(t,n);return Object.freeze(e)}const Y={getters:[y.Object,y.Map],typeValidators:[O.Object,O.Map],ancestors:[],depth:0,maxDepth:10};function ee(e,t={}){const n=Object.assign({},Y,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:s,values:r}=n;if(n.depth>n.maxDepth)return;n.depth++;const a=new M(n.getters,n.typeValidators).cess(e);s.includes(a)||s.unshift(a);const i=w(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,t]of i)s.includes(t)||b.includes(g(t))&&ee(t,n);return Object.seal(e)}var te=(e,t)=>w(e,"keys",t),ne=(e,t)=>w(e,"values",t),se=(e,t)=>w(e,"entries",t);const re={getters:[y.Object,y.Map],typeValidators:[O.Object,O.Map],delimiter:".",depth:0,enumerable:!0,frozen:!1,maxDepth:10,nonenumerable:!1,path:!1,recurse:!0,returnValue:"receiver",sealed:!1,type:!1};function ae(e,t,n={}){const s=Object.assign({},re,n,{ancestors:Object.assign([],n.ancestors)});if(s.depth>=s.maxDepth)return;s.depth++,s.ancestors.includes(e)||s.ancestors.unshift(e);const r=new M(s.getters,s.typeValidators).cess(e,t);if(void 0!==r){if(b.includes(g(r))){if(s.ancestors.includes(r))return;s.ancestors.unshift(r)}const n="map"!==g(e)?Object.getOwnPropertyDescriptor(e,t):{configurable:!1,enumerable:!0,value:r[1],writable:!0};if(!s.nonenumerable&&!n.enumerable)return;return s.path&&(s.path="string"===g(s.path)?[s.path,t].join(s.delimiter):t,n.path=s.path),s.type&&(n.type=g(r)),s.frozen&&(n.frozen=Object.isFrozen(r)),s.sealed&&(n.sealed=Object.isSealed(r)),s.recurse&&b.includes(g(r))?n.value=ie(r,s):n.value=r,n}}function ie(e,t={}){const n=Object.assign({},t),s={},r=g(e),a=["array","object"].includes(r)?Object.keys(Object.getOwnPropertyDescriptors(e)):"map"==r?Array.from(e.keys()):[];for(const t of a){const r=ae(e,t,n);r&&(s[t]=r)}return s}function oe(e,t={}){if("receiver"===Object.assign({},t).returnValue)return e;return Q(A(g(e)),ie(e,t))}const ce={space:0,replacer:null,returnValue:"target",nonenumerable:!0};function ue(e,t){const n=Object.assign({},ce,t);return JSON.stringify(oe(e,n),n.replacer,n.space)}EventTarget;class le{#e;#t=!1;#n=[];#s=[];#r;#a;#i;constructor(e,t){if(!e||!t)return this;const n=((e={})=>{const t={enable:!1,assign:"addEventListener",deassign:"removeEventListener",transsign:"dispatchEvent",bindListener:!0,errorLog:!1,scopeKey:":scope",pathMatch:!0,methods:{assign:{addEventListener:function(e,t){const{type:n,listener:s,settings:r}=e,{options:a,useCapture:i}=r;return t.addEventListener(n,s,a||i)},on:function(e,t){const{type:n,listener:s}=e;return t.on(n,s)},once:function(e,t){const{type:n,listener:s}=e;return t.once(n,s)}},deassign:{removeEventListener:function(e,t){const{type:n,listener:s,settings:r}=e,{options:a,useCapture:i}=r;return t.removeEventListener(n,s,a||i)},off:function(e,t){const{type:n,listener:s}=e;return t.off(n,s)}},transsign:{dispatchEvent:function(e,t,n){return t.dispatchEvent(n)},emit:function(e,t,n,...s){return t.emit(n,...s)}}}};for(const[n,s]of Object.entries(e))switch(n){case"methods":t[n]=R(t[n],s);break;case"enableEvents":break;default:t[n]=s}return t})(e);Object.defineProperties(this,{settings:{value:n},path:{value:n.path},type:{value:n.type},assigned:{value:[]},deassigned:{value:[]},transsigned:{value:[]},listener:{configurable:!0,get(){let e;if("string"===g(n.listener)){let s=t;e:for(const e of n.listener.split(".")){if(void 0===s[e])break e;s=s[e]}"function"===g(s)&&(e=s)}else e=n.listener;return!0===n.bindListener&&(e=e.bind(this.#e)),Object.defineProperty(this,"listener",{value:e}),e}}}),this.#e=t,this.enable=this.settings.enable}get enable(){return this.#t}set enable(e){const t=this.#o,n=this.assigned,s=this.deassigned;n.length=0,s.length=0;for(const r of t){const{path:t,target:a,enable:i}=r;this.settings;if(i!==e)if(!0===e)try{this.#c(a),r.enable=e,n.push(r)}catch(e){this.settings.errorLog&&console.error(e)}else if(!1===e)try{this.#u(a),r.enable=e,s.push(r)}catch(e){this.settings.errorLog&&console.error(e)}}this.#t=e}get#l(){return this.settings.target}get#o(){const e=this.#s,t=[];if(this.#l)for(const n of[].concat(this.#l)){const s=e.find((e=>e?.path===this.path));void 0!==s?t.push(s):void 0===s&&t.push({path:this.path,target:n,enable:!1})}else if("string"===g(this.path)){const n=[];if(this.settings.pathMatch){n.push(...D(this.#e,this.path,{nonenumerable:!0,pathMatch:!0})),"*"===this.path.charAt(0)&&n.unshift([this.#p,this.#e]);for(const[s,r]of n){const n=e.find((e=>e.path===s));let a,i=r;void 0!==i&&(i===n?.target?a=n:"object"==typeof i&&(a={path:s,target:i,enable:!1})),void 0!==a&&t.push(a)}}if(this.path===this.#p){const e={path:this.path,target:this.#e,enable:!1};t.push(e)}}return this.#s=t,this.#s}get#p(){return this.settings.scopeKey}get#c(){return void 0!==this.#r||(this.#r=this.settings.methods.assign[this.settings.assign].bind(null,this)),this.#r}get#u(){return void 0!==this.#a||(this.#a=this.settings.methods.deassign[this.settings.deassign].bind(null,this)),this.#a}get#f(){return void 0!==this.#i||(this.#i=this.settings.methods.transsign[this.settings.transsign].bind(null,this)),this.#i}emit(){const e=this.#o,t=this.transsigned,n=this.#n;t.length=0,n.length=0;for(const s of e){const{target:e}=s;try{this.#f(e,...arguments),t.push(s)}catch(e){n.push(s)}}return this}}class pe extends EventTarget{static implement=function(e,t){if(!e||!t)return;const n=((e={})=>{const t={events:{},enableEvents:!1,compand:{scopeKey:":scope",maxDepth:10},propertyDefinitions:{getEvents:"getEvents",addEvents:"addEvents",removeEvents:"removeEvents",enableEvents:"enableEvents",disableEvents:"disableEvents",reenableEvents:"reenableEvents",emitEvents:"emitEvents"}};for(const[n,s]of Object.entries(e))switch(n){case"propertyDefinitions":case"compand":t[n]=Object.assign(t[n],s);break;default:t[n]=s}return t})(t),s=[];return Object.defineProperties(e,{[n.propertyDefinitions.getEvents]:{enumerable:!1,writable:!1,value:function(){if(!arguments[0])return s;const e=[],t=[].concat(arguments[0]);for(const n of t)for(const t of s){let s;e:for(const[e,r]of Object.entries(n)){let n;if(n="listener"===e?t.settings[e]===r:t[e]===r,!1===s)break e;s=n}!0===s&&e.push(t)}return e}},[n.propertyDefinitions.addEvents]:{enumerable:!1,writable:!1,value:function(){if(!arguments.length)return e;let t=function(e,t=":scope"){if(Array.isArray(e)||void 0===e)return e;const n=[];for(const[s,r]of Object.entries(e)){const e=s.trim().split(" ");let a,i,o,c;1===e.length?(a=t,i=e[0]):e.length>1&&(a=e[0],i=e[1]),Array.isArray(r)?(o=r[0],c=r[1]):o=r;const u={type:i,path:a,listener:o,enable:!1};n.push(u)}return n}(arguments[0],n.compand.scopeKey),r=arguments[1]||!1;for(let a of t){const t={};for(const e of["assign","deassign","transsign","compand","bindListener"]){const s=n[e];void 0!==s&&(t[e]=s)}R(t,a);const i=new le(t,e);r&&(i.enable=!0),s.push(i)}return e}},[n.propertyDefinitions.removeEvents]:{enumerable:!1,writable:!1,value:function(){const t=e[n.propertyDefinitions.getEvents](arguments[0]);if(0===t.length)return e;let r=s.length-1;for(;r>-1;){const e=s[r];t.includes(e)&&(e.enable=!1,s.splice(r,1)),r--}return e}},[n.propertyDefinitions.enableEvents]:{enumerable:!1,writable:!1,value:function(){const t=e[n.propertyDefinitions.getEvents](arguments[0]);if(0===t.length)return e;for(const e of t)e.enable=!0;return e}},[n.propertyDefinitions.disableEvents]:{enumerable:!1,writable:!1,value:function(){const t=e[n.propertyDefinitions.getEvents](arguments[0]);if(0===t.length)return e;for(const e of t)e.enable=!1;return e}},[n.propertyDefinitions.reenableEvents]:{enumerable:!1,writable:!1,value:function(){const t=e[n.propertyDefinitions.getEvents](arguments[0]);for(const e of t)e.enable=!1,e.enable=!0;return e}},[n.propertyDefinitions.emitEvents]:{enumerable:!1,writable:!1,value:function(t,...s){const r=e[n.propertyDefinitions.getEvents](t);for(const e of r)e.emit(...s);return e}}}),n.events&&e[n.propertyDefinitions.addEvents](n.events),!0===n.enableEvents&&e[n.propertyDefinitions.enableEvents](),e};constructor(e={}){return super(),pe.implement(this,e)}}export{pe as default};
//# sourceMappingURL=core-plex.min.js.map
